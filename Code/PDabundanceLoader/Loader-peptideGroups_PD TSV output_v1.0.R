## PeptideGroups.txt (PD) Loader for Raw, Normalized, or Ratioed/GIS Reporter Abundance from Pdptide-level .txt TSV files generated by PD
## Eric Dammer -- Seyfried Lab Proteomics (2021)
#####################################################################################

## Prepare the workspace.

options(stringsAsFactors=FALSE)


########### Configuration ########################
rootdir="E:/OneDrive/HeparinPlasma.3b.TMT/ROCpipeline/peptides/"

## Specify dataType as one of the following 3:
## *   RAW Reporter Abundance (sometimes prefered for biofluid)
## **  Normalized Reporter Abundance (default/recommended)
## *** Abundance Ratio (/ single GIS control channel precalculated by PD)

dataType="rawAbundance"
#** dataType="normAbundance"
#*** dataType="abundanceRatio"

## Define batches, or a single multiconsensus, to load in a character vector
# Each batch file has a unique number, indicating the batch:
#  plexes <- c("b1","b2","b3","b4","b5")
# Or a single multiconsensus file can use any 1 placeholder string, which will not be considered as batch (just used for data.frame lists' name)
plexes <- c("multiconsensus")

## Specify minimum confidence level for proteins to load/keep from PD Proteins.txt input
minConfidence="high"  #currently ""low" "medium" or "high" implemented; high is 1% FDR generally.

## Specify Proteins.txt file(s)
fileToLoad="../../heparinplasmatmt_3batches_PeptideGroups.txt"
## if multiple plexes, create a name template if more than one file, using XXX in the template name, to be replaced once for each of the multiple plexes
# fileToLoad="csfplasma_neatandtop14dep_XXX_Proteins.txt"

outputFilename=paste0("1b.PD.TMT_",dataType,".NoCorrection.csv")

##END CONFIGURATION SECTION
###################################################

setwd(rootdir)
datadir <- paste0(rootdir)


#Load your species-specific lookup for UniprotID (Accession) to gene symbol THIS IS A 2 COLUMN FILE SEPARATE FROM PD OUTPUT
symbolLookup<-readxl::read_excel("2020-preference+2015_UniprotID-symbolLookupTableForR.xlsx") #column names will be set below to "Uniprot.ID" and "Symbol"
symbolLookup<-as.data.frame(symbolLookup)
colnames(symbolLookup)<-c("Uniprot.ID","Symbol")


peptideGroups<-exprMat0<-UIDs<-Xcorr<-Symbols<-list()
for (i in plexes) {
  ## ++ below line may require use of the variable plexes, if multiple non-multiconsensus files are being loaded.
  if(length(plexes)==1) peptideGroups[[i]]<-read.delim(file=paste0(datadir,"/",fileToLoad),sep="\t",header=TRUE) #,row.names=1 #decoys can have same ID
  if(length(plexes)>1) peptideGroups[[i]]<-read.delim(file=paste0(datadir,"/",gsub(i,"XXX",fileToLoad)),sep="\t",header=TRUE) #,row.names=1 #decoys can have same ID

  #dim(peptideGroups[[i]])

  # table(peptideGroups[[i]]$Protein.FDR.Confidence..Combined) # all hits may be prefiltered "High" confidence, or there may be high/medium/low
  # notHighConfCount=length(which(!peptideGroups[[i]]$Confidence=="High"))
  originalRows=nrow(peptideGroups[[i]])
  if (dataType=="rawAbundance")  keepColIndices=which(grepl(paste0("Abundance..F\\d+.."), colnames(peptideGroups[[i]])))
  if (dataType=="normAbundance")  keepColIndices=which(grepl(paste0("Abundances..Normalized...F\\d+.."), colnames(peptideGroups[[i]])))
  if (dataType=="abundanceRatio") keepColIndices=which(grepl("Abundance.Ratio...F\\d+..", colnames(peptideGroups[[i]])))

  # table(peptideGroups[[i]]$Confidence) # all hits are "High" confidence
  if (minConfidence=="high") keepRowIndices=which(peptideGroups[[i]]$Confidence=="High")
  if (minConfidence=="medium") keepRowIndices=which(peptideGroups[[i]]$Confidence=="High" | peptideGroups[[i]]$Confidence=="Medium")
  if (minConfidence=="low") keepRowIndices=which(peptideGroups[[i]]$Confidence=="High" | peptideGroups[[i]]$Confidence=="Medium" | peptideGroups[[i]]$Confidence=="Low")

  if (dataType=="rawAbundance") cat(paste0("Imported data for plex ",i," has ",originalRows,"x",ncol(peptideGroups[[i]])," rows x columns; ",length(keepRowIndices)," ",minConfidence,"+ confidence peptidoforms. RAW abundance is available for ",length(keepColIndices)," samples in file.\n"))
  if (dataType=="normAbundance") cat(paste0("Imported data for plex ",i," has ",originalRows,"x",ncol(peptideGroups[[i]])," rows x columns; ",length(keepRowIndices)," ",minConfidence,"+ confidence peptidoforms. Norm. Abundance is available for ",length(keepColIndices)," samples in file.\n"))
  if (dataType=="abundanceRatio") cat(paste0("Imported data for plex ",i," has ",originalRows,"x",ncol(peptideGroups[[i]])," rows x columns; ",length(keepRowIndices)," ",minConfidence,"+ confidence peptidoforms. Ratio/GIS(single channel) is available for ",length(keepColIndices)," samples in file.\n"))



  #make a matrix of just LFQ values with rownames as UniqueID (decoys removed, so they are truly unique now)
  exprMat0[[i]]<-peptideGroups[[i]][c(keepRowIndices),c(keepColIndices)]

  #Take first UniprotID as accession.
  UIDs[[i]]<-sapply(as.character(peptideGroups[[i]]$Master.Protein.Accessions), function(x) strsplit(x,"[;]")[1][1])   
  if(max(sapply(UIDs[[i]],length))>1) UIDs[[i]]<-unlist(lapply(UIDs[[i]],function(x) x[1]))  #fix for IDs that split and were carried in as vectors of multiple IDs for a single entry
  #below usual approach can lead to missed lines/entries, throwing off all labels of peptides!
  #UIDs[[i]]<-as.data.frame(do.call(rbind,strsplit(as.character(peptideGroups[[i]]$Master.Protein.Accessions),"[;]")))[,1]
  if(!length(UIDs[[i]])==dim(exprMat0[[i]])[1]) { print("UniprotIDs vector length does not match number of rows in expr matrix!"); break(); }

  Symbols[[i]]<- sapply(UIDs[[i]],function(x) symbolLookup[match(x,symbolLookup$Uniprot.ID),"Symbol"])
  #see unlooked-up accessions; using a text editor, you can add the missing lookups to the end of symbolLookup csv above.
  UIDs[[i]][which(is.na(Symbols[[i]]))]

  uniquePepIDs<-paste0(Symbols[[i]],"|",UIDs[[i]],"|",peptideGroups[[i]]$Annotated.Sequence,"|",peptideGroups[[i]]$Modifications)   #in earlier versions, Sequence instead of Annotated.Sequence

  rownames(exprMat0[[i]])<-uniquePepIDs
  exprMat0[[i]]<-as.matrix(exprMat0[[i]])
  dim(exprMat0[[i]])

  if (dataType=="rawAbundance") if (length(plexes)==1) colnames(exprMat0[[i]])<-gsub("..Sample","",gsub("..Control","",gsub("Abundance..F(\\d+)..(\\d+.)","b\\1\\.\\2",colnames(exprMat0[[i]]))))   #For unnormalized Abundance Pattern, 1 multiconsensus
  if (dataType=="rawAbundance") if (length(plexes) >1) colnames(exprMat0[[i]])<-paste0(i,".",gsub("..Sample","",gsub("..Control","",gsub("Abundance..F\\d+..(\\d+[N|C|\\.]).*","\\1",colnames(exprMat0[[i]])))))  #For unnormalized Abundance Pattern, multiple plexes
  if (dataType=="normAbundance") if (length(plexes)==1) colnames(exprMat0[[i]])<-gsub("..Sample","",gsub("..Control","",gsub("Abundances..Normalized...F(\\d+)..(\\d+.)","b\\1\\.\\2",colnames(exprMat0[[i]]))))   #For Normalized Abundance Pattern, 1 multiconsensus
  if (dataType=="normAbundance") if (length(plexes) >1) colnames(exprMat0[[i]])<-paste0(i,".",gsub("..Sample","",gsub("..Control","",gsub("Abundances..Normalized...F\\d+..(\\d+[N|C|\\.]).*","\\1",colnames(exprMat0[[i]])))))  #For Normalized Abundance Pattern, multiple plexes
  if (dataType=="abundanceRatio") if (length(plexes)==1) colnames(exprMat0[[i]])<-gsub("Abundance.Ratio...F(\\d+)..(\\d+[N|C|\\.]).*","b\\1\\.\\2",colnames(exprMat0[[i]]))   #For Abundance Ratio Pattern, 1 multiconsensus
  if (dataType=="abundanceRatio") if (length(plexes) >1) colnames(exprMat0[[i]])<-paste0(i,".",gsub("Abundance.Ratio...F\\d+..(\\d+[N|C|\\.]).*","\\1",colnames(exprMat0[[i]]))) #For Abundance Ratio Pattern, multiple plexes

  Xcorr[[i]]<-peptideGroups[[i]]$XCorr..by.Search.Engine...Sequest.HT
#  colnames(Xcorr[[i]])<-"Xcorr"
  names(Xcorr[[i]])<-rownames(exprMat0[[i]])
}

## Sample Output from above loading:
#Imported data for plex b1 has 17151x210 rows x columns; 17151 medium+ confidence master proteins. RAW abundance is available for 39 samples in file.
#Imported data for plex b1 has 17151x210 rows x columns; 17151 high+ confidence master proteins. RAW abundance is available for 39 samples in file.


#clean up data structures we will not use again
rm(peptideGroups)
rm(uniquePepIDs)
rm(normAbunIndices)

uniquePepIDs<-vector()
for (i in plexes) { uniquePepIDs<-unique(c(uniquePepIDs,rownames(exprMat0[[i]]))) }
length(uniquePepIDs) #17,151

uniquePepSeqs<-unique(as.data.frame(do.call(rbind,strsplit(as.character(uniquePepIDs),"[|]")))[,3])
length(uniquePepSeqs) #14,075


#if plexes count > 1, assemble the multi-plex protein abundance matrix:
if (length(plexes)>1) {
  cleanDat<-matrix(NA,nrow=length(uniquePepIDs),ncol=0)
  allPlexes<-ls(exprMat0)
  for (eachPlex in allPlexes) {
    plexDF<-t(sapply(uniquePepID,function(x)  tryCatch(exprMat0[[eachPlex]][x,], error=function(repNA) rep(NA,ncol(exprMat0[[eachPlex]]))) ))
    cleanDat<-cbind(cleanDat,plexDF)
    colnames(cleanDat)[(ncol(cleanDat)-(ncol(exprMat0[[eachPlex]])-1)):ncol(cleanDat)]<-colnames(exprMat0[[eachPlex]])
  }
  cleanDat.new<-cleanDat
  #for (i in 1:ncol(cleanDat)) colnames(exprMat0.rawAbun)[i]<-paste0("b",colnames(cleanDat)[i])
} else {   # multiconsensus in 1 loaded file
  cleanDat.new<-exprMat0[[plexes]]
}

## Enforce double-digit batch #s in sample (column) names
colnames(cleanDat.new)<-gsub("b(\\d)\\.","b0\\1.",colnames(cleanDat.new))

write.csv(cleanDat.new, file=outputFilename)



## We can derive normalized abundances from raw abundance.
  #calculate normalized Abundance from raw abundances summed by EKC, PD-style
  #per p535 in https://assets.thermofisher.com/TFS-Assets/CMD/manuals/Man-XCALI-97808-Proteome-Discoverer-User-ManXCALI97808-EN.pdf
  #scale all columns to max column (sample) sum
if(dataType=="rawAbundance") {
  exprMat0.rawAbun<-cleanDat.new
  maxColSum<-max(colSums(exprMat0.rawAbun,na.rm=T))
  exprMat0.norm<-apply(exprMat0.rawAbun,2,function(x) x*(maxColSum/sum(x,na.rm=T)))

  par(mfrow=c(1,2))
  hist(log2(colSums(exprMat0.rawAbun,na.rm=T)),main="Raw Abundance",xlab="log2(Summed Sample Abundance)") #peak typically more dispersed...
  hist(log2(colSums(exprMat0.norm,na.rm=T)),main="Normalized Abundance",xlab="log2(Summed Sample Abundance)")    #than for this data.
  #exprMat0.norm : data normalized for loading/total sum equivalence.
} 


## end PD peptideGroups.txt loader routine
